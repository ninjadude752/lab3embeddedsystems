;
; Lab3.asm
;
; Created: 2/28/2023 12:42:02 PM
; Author : Xinyi Yuan
;

; configure PC0, PC1 as input for RPG channel a and channel b

cbi DDRC, 1			; channel b
cbi DDRC, 0			; channel a
; configure PB0 as input for pushbutton

; output pins for 7 segment display
sbi DDRB, 3
sbi DDRB, 2
sbi DDRB, 1
cbi DDRB, 0 ; set PB0 input (push button)
cbi DDRB, 5 ; set PB5 input

 
;.set count = 100                          ; assign a 16-bit value to symbol "count"

.equ disp0 = 0x3F
.equ disp1 = 0x6
.equ disp2 = 0x5B
.equ disp3 = 0x4F
.equ disp4 = 0x66
.equ disp5 = 0x6D
.equ disp6 = 0x7D
.equ disp7 = 0x7
.equ disp8 = 0x7F
.equ disp9 = 0x6F
.equ dispa = 0b1110111
.equ dispb = 0b1111100
.equ dispc = 0b0111001
.equ dispd = 0b1011110
.equ dispe = 0b1111001
.equ dispf = 0b1110001
.equ dispsign = 0b1000000
.equ dispdot = 0b10000000
.equ dispFlash = 0x80

.def tmp1 = R29
.def tmp2 = R30 
.def counter = R31
;.equ tmp1 = 0
;.equ tmp2 = 0

 
ldi R16, 0x00
ldi R21, 0x00
ldi R25,  0x00
ldi R18, dispsign
ldi R26, 0x00
ldi R28, 0x01	// 1 indicates the correct code
ldi R29, 0x01
ldi R30, 0x02
ldi R31, 0x01
;ldi R23, 0x11
; Replace with your application code

start:
	rcall delay
	rcall display

	;rcall delay
	rjmp poll2
	rjmp start

display: ; backup used registers on stack
	push R18
	push R17
	in R17, SREG
	push R17
	ldi R17, 8 ; loop --> test all 8 bits
loop:
    rol R18
    BRCS set_ser_in_1 ; branch if Carry is set; put code here to set SER to 0
	cbi PORTB,3
	rjmp end
 
set_ser_in_1:
	sbi PORTB,3
end:
	sbi PORTB,2
	cbi PORTB,2
	; put code here to generate SRCLK pulse...
	dec R17
	brne loop
	; put code here to generate RCLK pulse
	sbi PORTB,1
	cbi PORTB,1
	; restore registers from stack
	pop R17
	out SREG, R17
	pop R17
	pop R18
	ret 



pollRPG:
	rcall readRPG
	cpi R16, 0b01001011
	breq clockwise_turn
	cpi R16, 0b10000111
	breq counterclock_turn
	rjmp start

clockwise_turn:
	cpi R25, 0x0F
	brlt count_up
	rjmp start
	count_up:
	inc R25
	rjmp count_to_digital

counterclock_turn:
	cpi R25, 0x00
	brne count_down
	rjmp start

	count_down:
	dec R25
	rjmp count_to_digital

count_to_digital:
	cpi R25, 0x00
    breq check_0
    cpi R25, 0x01
    breq check_1
    cpi R25, 0x02
    breq check_2
    cpi R25, 0x03
    breq check_3
    cpi R25, 0x04
    breq check_4
    cpi R25, 0x05
    breq check_5
    cpi R25, 0x06
    breq check_6
    cpi R25, 0x07
    breq check_7
    cpi R25, 0x08
    breq check_8
    cpi R25, 0x09
    breq check_9
	cpi R25, 0x0A
	breq check_a
	cpi R25, 0x0B
	breq check_b
	cpi R25, 0x0C
	breq check_c
	cpi R25, 0x0D
	breq check_d
	cpi R25, 0x0E
	breq check_e
	cpi R25, 0x0F
	breq check_f

check_0:
	clr R18
	ldi R18, disp0
	rjmp start
midway2:
	rjmp start
check_1:
	clr R18
	ldi R18, disp1
	rjmp start
check_2:
	clr R18
	ldi R18, disp2
	rjmp start
check_3:
	clr R18
	ldi R18, disp3
	rjmp start
check_4:
	clr R18
	ldi R18, disp4
	rjmp start
check_5:
	clr R18
	ldi R18, disp5
	rjmp start
check_6:
	clr R18
	ldi R18, disp6
	rjmp start
check_7:
	clr R18
	ldi R18, disp7
	rjmp start
check_8:
	clr R18
	ldi R18, disp8
	rjmp start
check_9:
	clr R18
	ldi R18, disp9
	rjmp start
check_a:
	clr R18
	ldi R18, dispa
	rjmp start
check_b:
	clr R18
	ldi R18, dispb
	rjmp start
check_c:
	clr R18
	ldi R18, dispc
	rjmp start
check_d:
	clr R18
	ldi R18, dispd
	rjmp start
check_e:
	clr R18
	ldi R18, dispe
	rjmp start
check_f:
	clr R18
	ldi R18, dispf
	rjmp start
check_sign:
	clr R18
	ldi R18, dispsign
	rjmp start
check_dot:
	clr R18
	ldi R18, dispdot
	rjmp start

jumpClockwise:
	rjmp clockwise_turn

jumpCounter:
	rjmp counterclock_turn

; read all 4 rpg "phase" into R16
readRPG:
	clr R16
	clr R21
	in R16, PINC
	andi R16, 0x03
	lsl R16
	lsl R16
	mov R21, R16
	in R16, PINC
	andi R16, 0x03
	or R16, R21
	lsl R16
	lsl R16
	mov R21, R16
	in R16, PINC
	andi R16, 0x03
	or R16, R21
	lsl R16
	lsl R16
	mov R21, R16
	in R16, PINC
	andi R16, 0x03
	or R16, R21
	ret


poll2:
	rcall readRPG2
	mov R23, R22
	andi R23, 0x3
	cp R16, R23 
	brne shiftAB
	sbis PINB, 0
	rcall check_loop
	rjmp poll2

shiftAB:
	lsl R22
	lsl R22
	Or R22, R16
	rjmp compare

readRPG2:
	in R16, PINC
	andi r16,0x03
	ret

compare:
	cpi R22, 0b11010010
	breq jumpClockwise
	cpi R22, 0b11100001
	breq jumpCounter
	rjmp poll2

check_loop:
	cpi R27, 0x00
	breq check0
	cpi R27, 0x01
	breq check1
	cpi R27, 0x02
	breq check2
	cpi R27, 0x03
	breq check3
	cpi R27, 0x04
	breq check4
        inc R27
	ret
	
check0:
	cpi R25, 0x05
	breq poll2
	ldi R28, 0x00		; indicates the wrong sequence
	ret
check1:
	cpi R25, 0x04
	breq poll2
	ldi R28, 0x00
	ret
check2:
	cpi R25, 0x06
	breq poll2
	ldi R28, 0x00
	ret
check3: 
	cpi R25, 0x0f
	breq poll2
	ldi R28, 0x00
	ret
check4:
	cpi R25, 0x04
	breq correct
	ldi R28, 0x00
	rjmp wrong

correct:
	clr R27
	cpi R28, 0x00
	breq wrong
	ldi R18, dispdot
	rjmp start

wrong:
	clr R27
	ldi R18, dispf
	rjmp start


; Wait for TIMER0 to roll over.
delay:
	; Stop timer 0.
	in		tmp1,TCCR0B    ; Save configuration
	ldi		tmp2,0x00      ; Stop timer 0
	out   TCCR0B,tmp2 
	; Clear overflow flag.     
	in    tmp2,TIFR0      ; tmp <-- TIFR0 
	sbr	  tmp2,1<<TOV0      ; Clear TOV0, write logic 1
	out   TIFR0,tmp2
	; Start timer with new initial count
	out   TCNT0, counter    ; Load counter
	out   TCCR0B,tmp1		; Restart timer
wait:
	in   tmp2,TIFR0      ; tmp <-- TIFR0 
	sbrs tmp2,TOV0      ; Check overflow flag
	rjmp wait
	ret
